// Generated by CoffeeScript 1.4.0

/*
(c) 2012-2013 Maciej Hirsz
Rippl may be freely distributed under the MIT license.
*/


(function() {
  var Canvas, Circle, Color, CustomShape, Element, Ellipse, ImageAsset, ObjectAbstract, Point, Rectangle, RelativePoint, Shape, Sprite, Text, Timer, Transformation, rippl, vendor, vendors, _i, _len,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.rippl = rippl = {};

  rippl.ObjectAbstract = ObjectAbstract = (function() {

    function ObjectAbstract() {}

    ObjectAbstract.prototype.options = {};

    ObjectAbstract.prototype._eventSeparator = new RegExp("\\s+");

    ObjectAbstract.prototype._validEventName = function(event) {
      if (typeof event !== 'string') {
        return false;
      }
      return true;
    };

    ObjectAbstract.prototype._validCallback = function(callback) {
      if (typeof callback !== 'function') {
        return false;
      }
      return true;
    };

    ObjectAbstract.prototype.on = function(events, callback) {
      var event, handlers, _i, _len, _ref;
      if (!this._validCallback(callback)) {
        return this;
      }
      _ref = events.split(this._eventSeparator);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        event = _ref[_i];
        handlers = this._eventHandlers || (this._eventHandlers = {});
        if (handlers[event] === void 0) {
          handlers[event] = [];
        }
        handlers[event].push(callback);
      }
      return this;
    };

    ObjectAbstract.prototype.once = function(event, callback) {
      var padding,
        _this = this;
      padding = function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        _this.off(event, padding);
        return callback.apply(_this, args);
      };
      return this.on(event, padding);
    };

    ObjectAbstract.prototype.off = function(event, callbackToRemove) {
      var args, callback, handlers, stack, _i, _j, _len, _len1, _ref, _ref1;
      if (!(handlers = this._eventHandlers)) {
        return this;
      }
      args = arguments.length;
      if (args === 0) {
        this._eventHandlers = {};
      } else if (args === 1) {
        if (handlers[event] === void 0) {
          return this;
        }
        delete handlers[event];
      } else if (event === null) {
        for (event in handlers) {
          stack = [];
          _ref = handlers[event];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            callback = _ref[_i];
            if (callback !== callbackToRemove) {
              stack.push(callback);
            }
          }
          handlers[event] = stack;
        }
      } else {
        if (handlers[event] === void 0) {
          return this;
        }
        stack = [];
        _ref1 = handlers[event];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          callback = _ref1[_j];
          if (callback !== callbackToRemove) {
            stack.push(callback);
          }
        }
        handlers[event] = stack;
      }
      return this;
    };

    ObjectAbstract.prototype.trigger = function() {
      var args, callback, event, handlers, _i, _len, _ref;
      event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (!(handlers = this._eventHandlers)) {
        return this;
      }
      if (!this._validEventName(event)) {
        return this;
      }
      if (handlers[event] === void 0) {
        return this;
      }
      _ref = handlers[event];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        callback.apply(this, args);
      }
      return this;
    };

    ObjectAbstract.prototype.addDefaults = function(defaults) {
      var option;
      if (this.options !== void 0) {
        for (option in this.options) {
          if (defaults[option] === void 0) {
            defaults[option] = this.options[option];
          }
        }
      }
      return this.options = defaults;
    };

    ObjectAbstract.prototype.setOptions = function(options) {
      var defaults, option;
      if (options !== void 0) {
        defaults = this.options;
        this.options = {};
        for (option in defaults) {
          if (options[option] !== void 0) {
            this.options[option] = options[option];
          } else {
            this.options[option] = defaults[option];
          }
        }
        return true;
      }
      return false;
    };

    return ObjectAbstract;

  })();

  if (Date.now === void 0) {
    Date.now = (function() {
      return (new this).getTime();
    });
  }

  if (window.requestAnimationFrame === void 0) {
    vendors = ['ms', 'moz', 'webkit', 'o'];
    for (_i = 0, _len = vendors.length; _i < _len; _i++) {
      vendor = vendors[_i];
      if (window[vendor + 'RequestAnimationFrame']) {
        window.requestAnimationFrame = window[vendor + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendor + 'CancelAnimationFrame'] || window[vendor + 'CancelRequestAnimationFrame'];
      }
    }
  }

  Timer = (function(_super) {

    __extends(Timer, _super);

    Timer.prototype._useAnimationFrame = false;

    Timer.prototype._frameDuration = 1000 / 60;

    function Timer() {
      if (window.requestAnimationFrame) {
        this._useAnimationFrame = true;
      }
      this.canvas = [];
      this.start();
    }

    Timer.prototype.bind = function(canvas) {
      return this.canvas.push(canvas);
    };

    Timer.prototype.start = function() {
      var _this = this;
      this.time = Date.now();
      if (this._useAnimationFrame) {
        return this.timerid = window.requestAnimationFrame(function(time) {
          return _this.tick(time);
        });
      } else {
        return this.timerid = setTimeout(function() {
          return _this.tickLegacy();
        }, this._frameDuration);
      }
    };

    Timer.prototype.stop = function() {
      if (this._useAnimationFrame) {
        return window.cancelAnimationFrame(this.timerid);
      } else {
        return window.clearTimeout(this.timerid);
      }
    };

    Timer.prototype.getSeconds = function() {
      return ~~(Date.now() / 1000);
    };

    Timer.prototype.tick = function(frameTime) {
      var canvas, _j, _len1, _ref,
        _this = this;
      frameTime = Date.now();
      this.trigger('frame', frameTime);
      _ref = this.canvas;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        canvas = _ref[_j];
        canvas.render(frameTime);
      }
      return this.timerid = window.requestAnimationFrame(function(time) {
        return _this.tick(time);
      });
    };

    Timer.prototype.tickLegacy = function() {
      var canvas, delay, frameTime, postRenderTime, _j, _len1, _ref,
        _this = this;
      frameTime = Date.now();
      this.time += this._frameDuration;
      this.trigger('frame', frameTime);
      _ref = this.canvas;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        canvas = _ref[_j];
        canvas.render(frameTime);
      }
      postRenderTime = Date.now();
      delay = this.time - postRenderTime;
      if (delay < 0) {
        delay = 0;
        this.time = postRenderTime;
      }
      return this.timerid = window.setTimeout(function() {
        return _this.tickLegacy();
      }, delay);
    };

    return Timer;

  })(ObjectAbstract);

  rippl.timer = new Timer;

  rippl.Color = Color = (function() {

    Color.prototype.r = 255;

    Color.prototype.g = 255;

    Color.prototype.b = 255;

    Color.prototype.a = 1;

    Color.prototype.__isColor = true;

    Color.prototype.string = 'rgba(255,255,255,1)';

    Color.prototype.rgbaPattern = new RegExp('\\s*rgba\\(\\s*(\\d{1,3})\\s*\\,\\s*(\\d{1,3})\\s*\\,\\s*(\\d{1,3})\\s*\\,\\s*(\\d+\.?\\d*|\\d*\.?\\d+)\s*\\)\\s*', 'i');

    function Color(r, g, b, a) {
      var hash, l, matches;
      if (typeof r === 'string') {
        if (r[0] === '#') {
          hash = r;
          l = hash.length;
          if (l === 7) {
            r = parseInt(hash.slice(1, 3), 16);
            g = parseInt(hash.slice(3, 5), 16);
            b = parseInt(hash.slice(5, 7), 16);
          } else if (l === 4) {
            r = parseInt(hash[1] + hash[1], 16);
            g = parseInt(hash[2] + hash[2], 16);
            b = parseInt(hash[3] + hash[3], 16);
          } else {
            throw "Invalid color string: " + hash;
          }
        } else if (matches = r.match(this.rgbaPattern)) {
          r = Number(matches[1]);
          g = Number(matches[2]);
          b = Number(matches[3]);
          a = Number(matches[4]);
        } else {
          throw "Invalid color string: " + r;
        }
      }
      this.set(r, g, b, a);
    }

    Color.prototype.set = function(r, g, b, a) {
      this.r = ~~r;
      this.g = ~~g;
      this.b = ~~b;
      if (a !== void 0) {
        this.a = a;
      }
      return this.cacheString();
    };

    Color.prototype.cacheString = function() {
      return this.string = "rgba(" + this.r + "," + this.g + "," + this.b + "," + this.a + ")";
    };

    Color.prototype.toString = function() {
      return this.string;
    };

    return Color;

  })();

  rippl.Point = Point = (function(_super) {

    __extends(Point, _super);

    Point.prototype.x = 0;

    Point.prototype.y = 0;

    Point.prototype.__isPoint = true;

    Point.prototype.canvas = null;

    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    Point.prototype.bind = function(canvas) {
      this.canvas = canvas;
      return this;
    };

    Point.prototype.move = function(x, y) {
      if (x !== null) {
        this.x = x;
      }
      if (y !== null) {
        this.y = y;
      }
      if (this.canvas !== null) {
        this.canvas.touch();
      }
      this.trigger('move', this);
      return this;
    };

    return Point;

  })(ObjectAbstract);

  rippl.RelativePoint = RelativePoint = (function(_super) {

    __extends(RelativePoint, _super);

    RelativePoint.prototype.x = 0;

    RelativePoint.prototype.y = 0;

    RelativePoint.prototype.vectorX = 0;

    RelativePoint.prototype.vectorY = 0;

    RelativePoint.prototype.root = null;

    RelativePoint.prototype.__isPoint = true;

    RelativePoint.prototype.canvas = null;

    function RelativePoint(x, y, root) {
      var _this = this;
      if (!root.__isPoint) {
        throw "Tried to create a RelativePoint with invalid root Point";
      }
      this.x = x + root.x;
      this.y = y + root.y;
      this.vectorX = x;
      this.vectorY = y;
      this.root = root;
      root.on('move', function(root) {
        _this.x = root.x + _this.vectorX;
        _this.y = root.y + _this.vectorY;
        return _this.trigger('move', _this);
      });
    }

    RelativePoint.prototype.bind = function(canvas) {
      this.canvas = canvas;
      return this;
    };

    RelativePoint.prototype.move = function(x, y) {
      if (x !== null) {
        this.x = this.root.x + x;
        this.vectorX = x;
      }
      if (y !== null) {
        this.y = this.root.y + y;
        this.vectorY = y;
      }
      if (this.canvas !== null) {
        this.canvas.touch();
      }
      this.trigger('move', this);
      return this;
    };

    return RelativePoint;

  })(ObjectAbstract);

  Transformation = (function(_super) {

    __extends(Transformation, _super);

    Transformation.prototype.startTime = 0;

    Transformation.prototype.finished = false;

    Transformation.prototype.options = {
      duration: 1000,
      delay: 0,
      from: null,
      to: null,
      custom: null,
      transition: 'linear'
    };

    Transformation.prototype.transitions = {
      linear: function(stage) {
        return stage;
      },
      easeOut: function(stage) {
        return Math.sin(stage * Math.PI / 2);
      },
      easeIn: function(stage) {
        return 1 - Math.sin((1 - stage) * Math.PI / 2);
      },
      easeInOut: function(stage) {
        stage = stage * 2 - 1;
        return (Math.sin(stage * Math.PI / 2) + 1) / 2;
      }
    };

    function Transformation(options) {
      this.setOptions(options);
      if (this.options.from === null) {
        this.options.from = {};
      }
      if (this.options.to === null) {
        this.options.to = {};
      }
      this.startTime = Date.now() + this.options.delay;
      this.endTime = this.startTime + this.options.duration;
    }

    Transformation.prototype.isFinished = function() {
      return this.finished;
    };

    Transformation.prototype.getStage = function(time) {
      var stage, transition;
      if (time <= this.startTime) {
        return 0;
      }
      if (time >= this.endTime) {
        return 1;
      }
      stage = (time - this.startTime) / this.options.duration;
      transition = this.transitions[this.options.transition];
      if (typeof transition === 'function') {
        return transition(stage);
      } else {
        throw "Unknown transition: " + this.options.transition;
      }
    };

    Transformation.prototype.getValue = function(from, to, stage) {
      if (typeof from === 'number') {
        return (from * (1 - stage)) + (to * stage);
      }
      if (from.__isColor) {
        return new Color(this.getValue(from.r, to.r, stage), this.getValue(from.g, to.g, stage), this.getValue(from.b, to.b, stage), this.getValue(from.a, to.a, stage));
      }
      return to;
    };

    Transformation.prototype.progress = function(element, time) {
      var from, option, options, stage, to;
      if (this.finished) {
        return;
      }
      if (time < this.startTime) {
        return;
      }
      options = {};
      stage = this.getStage(time);
      if (typeof this.options.custom === 'function') {
        this.options.custom.call(element, stage);
      }
      from = this.options.from;
      to = this.options.to;
      for (option in to) {
        options[option] = this.getValue(from[option], to[option], stage);
      }
      element.set(options);
      if (time >= this.endTime) {
        this.destroy();
        this.finished = true;
        return this.trigger('end');
      }
    };

    Transformation.prototype.destroy = function() {
      delete this.options.to;
      return delete this.options.from;
    };

    return Transformation;

  })(ObjectAbstract);

  rippl.ImageAsset = ImageAsset = (function(_super) {

    __extends(ImageAsset, _super);

    ImageAsset.prototype.__isAsset = true;

    ImageAsset.prototype.__isLoaded = false;

    ImageAsset.prototype._width = 0;

    ImageAsset.prototype._height = 0;

    function ImageAsset(url) {
      var _this = this;
      this._image = new Image;
      this._image.onload = function() {
        _this._width = _this._image.naturalWidth;
        _this._height = _this._image.naturalHeight;
        _this.__isLoaded = true;
        _this.trigger('loaded');
        return _this.off('loaded');
      };
      this._image.src = url;
    }

    ImageAsset.prototype.cache = function() {
      var args, buffer, cache, filter, label;
      label = arguments[0], filter = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      if (!this.__isLoaded) {
        return;
      }
      cache = this._cache || (this._cache = {});
      buffer = cache[label] = new Canvas({
        width: this._width,
        height: this._height,
        "static": true
      });
      buffer.drawAsset(this, 0, 0, this._width, this._height);
      args.unshift(filter);
      return buffer.filter.apply(buffer, args);
    };

    ImageAsset.prototype.cached = function(label) {
      if (!this._cache) {
        return this;
      }
      if (this._cache[label]) {
        return this._cache[label];
      }
      return this;
    };

    ImageAsset.prototype.getDocumentElement = function() {
      if (this.__isLoaded) {
        return this._image;
      }
      return null;
    };

    return ImageAsset;

  })(ObjectAbstract);

  rippl.assets = {
    _assets: {},
    get: function(url) {
      if (this._assets[url] !== void 0) {
        return this._assets[url];
      }
      return this._assets[url] = new ImageAsset(url);
    },
    define: function(url, dataurl) {
      return this._assets[url] = new ImageAsset(dataurl);
    },
    preload: function(urls, callback) {
      var asset, count, url, _j, _len1, _results;
      if (typeof urls === 'string') {
        urls = [urls];
      }
      count = urls.length;
      _results = [];
      for (_j = 0, _len1 = urls.length; _j < _len1; _j++) {
        url = urls[_j];
        asset = this.get(url);
        if (asset.__isLoaded) {
          count -= 1;
          if (count === 0 && typeof callback === 'function') {
            _results.push(callback());
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(asset.on('loaded', function() {
            count -= 1;
            if (count === 0 && typeof callback === 'function') {
              return callback();
            }
          }));
        }
      }
      return _results;
    }
  };

  (function(rippl) {
    var lumaChromaHueToRgb, rgbToChroma, rgbToLuma, rgbToLumaChromaHue;
    rgbToLuma = function(r, g, b) {
      return 0.30 * r + 0.59 * g + 0.11 * b;
    };
    rgbToChroma = function(r, g, b) {
      return Math.max(r, g, b) - Math.min(r, g, b);
    };
    rgbToLumaChromaHue = function(r, g, b) {
      var chroma, hprime, hue, luma;
      luma = rgbToLuma(r, g, b);
      chroma = rgbToChroma(r, g, b);
      if (chroma === 0) {
        hprime = 0;
      } else if (r === max) {
        hprime = ((g - b) / chroma) % 6;
      } else if (g === max) {
        hprime = ((b - r) / chroma) + 2;
      } else if (b === max) {
        hprime = ((r - g) / chroma) + 4;
      }
      hue = hprime * (Math.PI / 3);
      return [luma, chroma, hue];
    };
    lumaChromaHueToRgb = function(luma, chroma, hue) {
      var b, component, g, hprime, r, sextant, x;
      hprime = hue / (Math.PI / 3);
      x = chroma * (1 - Math.abs(hprime % 2 - 1));
      sextant = ~~hprime;
      switch (sextant) {
        case 0:
          r = chroma;
          g = x;
          b = 0;
          break;
        case 1:
          r = x;
          g = chroma;
          b = 0;
          break;
        case 2:
          r = 0;
          g = chroma;
          b = x;
          break;
        case 3:
          r = 0;
          g = x;
          b = chroma;
          break;
        case 4:
          r = x;
          g = 0;
          b = chroma;
          break;
        case 5:
          r = chroma;
          g = 0;
          b = x;
      }
      component = luma - rgbToLuma(r, g, b);
      r += component;
      g += component;
      b += component;
      return [r, g, b];
    };
    return rippl.filters = {
      colorOverlay: function(color) {
        var ctx;
        if (!color.__isColor) {
          color = new Color(color);
        }
        ctx = this.ctx;
        ctx.save();
        ctx.globalCompositeOperation = 'source-atop';
        ctx.fillStyle = color.toString();
        ctx.fillRect(0, 0, this._width, this._height);
        return ctx.restore();
      },
      invertColors: function() {
        return this.rgbaFilter(function(r, g, b, a) {
          r = 255 - r;
          g = 255 - g;
          b = 255 - b;
          return [r, g, b, a];
        });
      },
      saturation: function(saturation) {
        var grayscale;
        saturation += 1;
        grayscale = 1 - saturation;
        return this.rgbaFilter(function(r, g, b, a) {
          var luma;
          luma = rgbToLuma(r, g, b);
          r = r * saturation + luma * grayscale;
          g = g * saturation + luma * grayscale;
          b = b * saturation + luma * grayscale;
          return [r, g, b, a];
        });
      },
      contrast: function(contrast) {
        var gray, original;
        gray = -contrast;
        original = 1 + contrast;
        return this.rgbaFilter(function(r, g, b, a) {
          r = r * original + 127 * gray;
          g = g * original + 127 * gray;
          b = b * original + 127 * gray;
          return [r, g, b, a];
        });
      },
      brightness: function(brightness) {
        var change;
        change = 255 * brightness;
        return this.rgbaFilter(function(r, g, b, a) {
          r += change;
          g += change;
          b += change;
          return [r, g, b, a];
        });
      },
      gamma: function(gamma) {
        gamma += 1;
        return this.rgbaFilter(function(r, g, b, a) {
          r *= gamma;
          g *= gamma;
          b *= gamma;
          return [r, g, b, a];
        });
      },
      hueShift: function(shift) {
        var fullAngle,
          _this = this;
        fullAngle = Math.PI * 2;
        shift = shift % fullAngle;
        return this.rgbaFilter(function(r, g, b, a) {
          var chroma, hue, luma, _ref, _ref1;
          _ref = rgbToLumaChromaHue(r, g, b), luma = _ref[0], chroma = _ref[1], hue = _ref[2];
          hue = (hue + shift) % fullAngle;
          if (hue < 0) {
            hue += fullAngle;
          }
          _ref1 = lumaChromaHueToRgb(luma, chroma, hue), r = _ref1[0], g = _ref1[1], b = _ref1[2];
          return [r, g, b, a];
        });
      },
      colorize: function(hue) {
        hue = hue % (Math.PI * 2);
        return this.rgbaFilter(function(r, g, b, a) {
          var chroma, luma, _ref;
          luma = rgbToLuma(r, g, b);
          chroma = rgbToChroma(r, g, b);
          _ref = lumaChromaHueToRgb(luma, chroma, hue), r = _ref[0], g = _ref[1], b = _ref[2];
          return [r, g, b, a];
        });
      },
      ghost: function(alpha, hue) {
        var opacity;
        opacity = 1 - alpha;
        return this.rgbaFilter(function(r, g, b, a) {
          var chroma, luma, _ref;
          luma = rgbToLuma(r, g, b);
          if (typeof hue === 'number') {
            chroma = rgbToChroma(r, g, b);
            _ref = lumaChromaHueToRgb(luma, chroma, hue), r = _ref[0], g = _ref[1], b = _ref[2];
          }
          a = (a / 255) * (luma * alpha + 255 * opacity);
          return [r, g, b, a];
        });
      }
    };
  })(rippl);

  Element = (function(_super) {

    __extends(Element, _super);

    Element.prototype.options = {
      position: null,
      x: 0,
      y: 0,
      z: 0,
      snap: false,
      anchorX: 0.5,
      anchorY: 0.5,
      anchorInPixels: false,
      width: 0,
      height: 0,
      alpha: 1.0,
      rotation: 0.0,
      scaleX: 1.0,
      scaleY: 1.0,
      skewX: 0,
      skewY: 0,
      hidden: false,
      input: false,
      composition: 'source-over'
    };

    Element.prototype.tranformStack = [];

    Element.prototype.canvas = null;

    Element.prototype.__isElement = true;

    function Element(options) {
      var _this = this;
      this.setOptions(options);
      this.validate(this.options);
      this.transformStack = [];
      this.transformCount = 0;
      this.on('change:anchorX change:anchorY change:anchorInPixels', function() {
        return _this.calculateAnchor();
      });
      this.calculateAnchor();
    }

    Element.prototype.validate = function(options) {
      if (options.position != null) {
        options.x = options.position.x;
        options.y = options.position.y;
        if (this.canvas !== null) {
          return options.position.bind(this.canvas);
        }
      } else {
        if (this.options.position === null) {
          this.options.position = new Point(this.options.x, this.options.y);
          if (this.canvas !== null) {
            this.options.position.bind(this.canvas);
          }
        }
        if (options.x !== void 0) {
          this.options.position.move(options.x, null);
        }
        if (options.y !== void 0) {
          return this.options.position.move(null, options.y);
        }
      }
    };

    Element.prototype.bind = function(canvas) {
      this.canvas = canvas;
      if (this.options.position !== null) {
        return this.options.position.bind(canvas);
      }
    };

    Element.prototype.validateColor = function(value) {
      if (!value.__isColor) {
        value = new Color(value);
      }
      return value;
    };

    Element.prototype.calculateAnchor = function() {
      if (this.options.anchorInPixels) {
        this._anchor = {
          x: this.options.anchorX,
          y: this.options.anchorY
        };
      } else {
        this._anchor = {
          x: this.options.anchorX * this.options.width,
          y: this.options.anchorY * this.options.height
        };
      }
      if (this.options.snap) {
        this._anchor.x = Math.round(this._anchor.x);
        return this._anchor.y = Math.round(this._anchor.y);
      }
    };

    Element.prototype.getAnchor = function() {
      return this._anchor;
    };

    Element.prototype.hide = function() {
      if (this.options.hidden) {
        return;
      }
      this.options.hidden = true;
      return this.canvas.touch();
    };

    Element.prototype.show = function() {
      if (!this.options.hidden) {
        return;
      }
      this.options.hidden = false;
      return this.canvas.touch();
    };

    Element.prototype.isHidden = function() {
      return this.options.hidden;
    };

    Element.prototype.transform = function(options) {
      var option, transform, _ref, _ref1;
            if ((_ref = options.from) != null) {
        _ref;

      } else {
        options.from = {};
      };
            if ((_ref1 = options.to) != null) {
        _ref1;

      } else {
        options.to = {};
      };
      for (option in options.to) {
        if (options.from[option] === void 0) {
          options.from[option] = this.options[option];
        }
      }
      for (option in options.from) {
        if (options.to[option] === void 0) {
          options.to[option] = this.options[option];
        }
      }
      this.validate(options.from);
      this.validate(options.to);
      transform = new Transformation(options);
      this.transformStack.push(transform);
      this.transformCount += 1;
      return transform;
    };

    Element.prototype.stop = function() {
      var transform, _j, _len1, _ref;
      if (!this.transformStack) {
        return;
      }
      _ref = this.transformStack;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        transform = _ref[_j];
        transform.destroy();
      }
      this.transformStack = [];
      return this.transformCount = 0;
    };

    Element.prototype.progress = function(frameTime) {
      var newStack, remove, transform, _j, _k, _len1, _len2, _ref, _ref1;
      if (!this.transformCount) {
        return;
      }
      remove = false;
      _ref = this.transformStack;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        transform = _ref[_j];
        transform.progress(this, frameTime);
        if (transform.isFinished()) {
          remove = true;
        }
      }
      if (remove) {
        newStack = [];
        _ref1 = this.transformStack;
        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
          transform = _ref1[_k];
          if (!transform.isFinished()) {
            newStack.push(transform);
          }
        }
        this.transformStack = newStack;
        return this.transformCount = newStack.length;
      }
    };

    Element.prototype.prepare = function() {
      var ctx, options, x, y;
      ctx = this.canvas.ctx;
      options = this.options;
      x = options.position.x;
      y = options.position.y;
      if (options.snap) {
        x = Math.round(x);
        y = Math.round(y);
      }
      ctx.setTransform(options.scaleX, options.skewX, options.skewY, options.scaleY, x, y);
      if (options.alpha !== 1) {
        ctx.globalAlpha = options.alpha;
      }
      if (options.rotation !== 0) {
        ctx.rotate(options.rotation);
      }
      if (options.composition !== 'source-over') {
        return ctx.globalCompositeOperation = options.composition;
      }
    };

    Element.prototype.render = function() {};

    Element.prototype.pointOnElement = function(x, y) {
      var anchor, cos, options, sin, xrot, yrot;
      anchor = this.getAnchor();
      options = this.options;
      x = x - options.position.x;
      y = y - options.position.y;
      if (options.scaleX === 0 || options.scaleY === 0) {
        return false;
      }
      if (options.scaleX !== 1) {
        x = x / options.scaleX;
      }
      if (options.scaleY !== 1) {
        y = y / options.scaleY;
      }
      if (options.rotation !== 0) {
        cos = Math.cos(-options.rotation);
        sin = Math.sin(-options.rotation);
        xrot = cos * x - sin * y;
        yrot = sin * x + cos * y;
        x = xrot;
        y = yrot;
      }
      if (x < -anchor.x || x > options.width - anchor.x) {
        return false;
      }
      if (y < -anchor.y || y > options.height - anchor.y) {
        return false;
      }
      return true;
    };

    Element.prototype.delegateInputEvent = function(type, x, y) {
      if (this.options.input === false) {
        return false;
      }
      if (this.pointOnElement(x, y) === false) {
        return false;
      }
      this.trigger(type);
      return true;
    };

    Element.prototype.set = function(target, value) {
      var change, option, options, _j, _len1;
      if (value !== void 0 && typeof target === 'string') {
        options = {};
        options[target] = value;
        target = options;
      }
      change = [];
      this.validate(target);
      for (option in target) {
        value = target[option];
        if (this.options[option] !== void 0 && this.options[option] !== value) {
          this.options[option] = value;
          change.push(option);
        }
      }
      if (change.length) {
        for (_j = 0, _len1 = change.length; _j < _len1; _j++) {
          option = change[_j];
          this.trigger("change:" + option);
        }
        return this.trigger("change");
      }
    };

    Element.prototype.get = function(option) {
      return this.options[option];
    };

    return Element;

  })(ObjectAbstract);

  rippl.Sprite = Sprite = (function(_super) {

    __extends(Sprite, _super);

    Sprite.prototype.buffer = null;

    Sprite.prototype._useBuffer = false;

    Sprite.prototype._animated = false;

    Sprite.prototype._frameDuration = 0;

    Sprite.prototype._framesModulo = 0;

    function Sprite(options, canvas) {
      this.addDefaults({
        src: null,
        cropX: 0,
        cropY: 0
      });
      Sprite.__super__.constructor.call(this, options, canvas);
    }

    Sprite.prototype.validate = function(options) {
      var asset,
        _this = this;
      Sprite.__super__.validate.call(this, options);
      if (options.src !== void 0) {
        if (typeof options.src === 'string') {
          options.src = asset = rippl.assets.get(options.src);
        } else {
          asset = options.src;
        }
        if (!asset.__isLoaded) {
          return asset.once('loaded', function() {
            if (_this.canvas) {
              _this.canvas.touch();
            }
            _this.calculateFrames();
            return _this.calculateAnchor();
          });
        } else {
          return this.calculateFrames();
        }
      }
    };

    Sprite.prototype.calculateFrames = function() {
      var src;
      src = this.options.src;
      if (this.options.width === 0) {
        this.options.width = src._width;
      }
      if (this.options.height === 0) {
        this.options.height = src._height;
      }
      return this._framesModulo = ~~(src._width / this.options.width);
    };

    Sprite.prototype.render = function() {
      var anchor;
      anchor = this.getAnchor();
      if (this._useBuffer) {
        return this.canvas.drawAsset(this.buffer, -anchor.x, -anchor.y, this.options.width, this.options.height);
      } else {
        return this.canvas.drawAsset(this.options.src, -anchor.x, -anchor.y, this.options.width, this.options.height, this.options.cropX, this.options.cropY);
      }
    };

    Sprite.prototype.addAnimation = function(label, fps, frames, lastFrame) {
      var animations, _j, _results;
      if (fps <= 0) {
        fps = 1;
      }
      if (typeof frames === 'number') {
        if (typeof lastFrame !== 'number') {
          lastFrame = frames;
        }
        frames = (function() {
          _results = [];
          for (var _j = frames; frames <= lastFrame ? _j <= lastFrame : _j >= lastFrame; frames <= lastFrame ? _j++ : _j--){ _results.push(_j); }
          return _results;
        }).apply(this);
      }
      animations = this._animations || (this._animations = {});
      animations[label] = {
        frames: frames,
        frameDuration: 1000 / fps
      };
      return this;
    };

    Sprite.prototype.animate = function(label) {
      var animation;
            if (label != null) {
        label;

      } else {
        label = 'idle';
      };
      animation = this._animations[label];
      if (!animation) {
        return;
      }
      this._frames = animation.frames;
      this._frameDuration = animation.frameDuration;
      this._currentIndex = -1;
      this._animationStart = Date.now();
      this._animationEnd = this._animationStart + this._frames.length * this._frameDuration;
      return this._animated = true;
    };

    Sprite.prototype.progress = function(frameTime) {
      var index;
      if (this._animated && this._framesModulo) {
        if (frameTime >= this._animationEnd) {
          return this.animate();
        }
        index = ~~((frameTime - this._animationStart) / this._frameDuration);
        if (index !== this._currentIndex) {
          this._currentIndex = index;
          this.setFrame(this._frames[index]);
        }
      }
      return Sprite.__super__.progress.call(this, frameTime);
    };

    Sprite.prototype.setFrame = function(frame) {
      var frameX, frameY;
      this._useBuffer = false;
      frameX = frame % this._framesModulo;
      frameY = ~~(frame / this._framesModulo);
      this.options.cropX = frameX * this.options.width;
      this.options.cropY = frameY * this.options.height;
      return this.canvas.touch();
    };

    Sprite.prototype.freeze = function() {
      return this._animated = false;
    };

    Sprite.prototype.createBuffer = function() {
      if (!this.buffer) {
        this.buffer = new Canvas({
          width: this.options.width,
          height: this.options.height,
          "static": true
        });
      } else {
        this.buffer.clear();
      }
      this.buffer.drawAsset(this.options.src, 0, 0, this.options.width, this.options.height, this.options.cropX, this.options.cropY);
      return this.buffer;
    };

    Sprite.prototype.filter = function() {
      var args, filter, fn;
      filter = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      fn = rippl.filters[filter];
      if (typeof fn !== 'function') {
        return;
      }
      this.createBuffer();
      this._useBuffer = true;
      fn.apply(this.buffer, args);
      return this.canvas.touch();
    };

    Sprite.prototype.clearFilters = function() {
      if (!(this.buffer != null)) {
        return;
      }
      this.buffer.clear();
      return this.buffer.drawAsset(this.options.src, 0, 0, this.options.width, this.options.height, this.options.cropX, this.options.cropY);
    };

    Sprite.prototype.removeFilter = function() {
      delete this.buffer;
      this.buffer = null;
      return this.canvas.touch();
    };

    return Sprite;

  })(Element);

  Shape = (function(_super) {

    __extends(Shape, _super);

    function Shape(options, canvas) {
      this.addDefaults({
        stroke: 0,
        strokeColor: '#000',
        lineCap: 'butt',
        lineJoin: 'miter',
        erase: false,
        fill: true,
        color: '#000',
        shadow: false,
        shadowX: 0,
        shadowY: 0,
        shadowBlur: 0,
        shadowColor: '#000'
      });
      Shape.__super__.constructor.call(this, options, canvas);
    }

    Shape.prototype.validate = function(options) {
      Shape.__super__.validate.call(this, options);
      if (options.color !== void 0) {
        options.color = this.validateColor(options.color);
      }
      if (options.strokeColor !== void 0) {
        options.strokeColor = this.validateColor(options.strokeColor);
      }
      if (options.shadowColor !== void 0) {
        return options.shadowColor = this.validateColor(options.shadowColor);
      }
    };

    Shape.prototype.drawPath = function() {};

    Shape.prototype.render = function() {
      var ctx;
      if (this.options.shadow) {
        this.canvas.setShadow(this.options.shadowX, this.options.shadowY, this.options.shadowBlur, this.options.shadowColor);
      }
      ctx = this.canvas.ctx;
      ctx.beginPath();
      ctx.lineCap = this.options.lineCap;
      ctx.lineJoin = this.options.lineJoin;
      this.drawPath();
      if (this.options.erase) {
        ctx.save();
        ctx.globalCompositeOperation = 'destination-out';
        ctx.globalAlpha = 1.0;
        this.canvas.fill('#000000');
        ctx.restore();
      }
      if (this.options.fill) {
        this.canvas.fill(this.options.color);
      }
      if (this.options.stroke > 0) {
        return this.canvas.stroke(this.options.stroke, this.options.strokeColor);
      }
    };

    return Shape;

  })(Element);

  rippl.Text = Text = (function(_super) {

    __extends(Text, _super);

    function Text(options, canvas) {
      this.addDefaults({
        label: 'Rippl',
        align: 'center',
        baseline: 'middle',
        italic: false,
        bold: false,
        size: 12,
        font: 'sans-serif'
      });
      Text.__super__.constructor.call(this, options, canvas);
    }

    Text.prototype.render = function() {
      var font;
      if (this.options.shadow) {
        this.canvas.setShadow(this.options.shadowX, this.options.shadowY, this.options.shadowBlur, this.options.shadowColor);
      }
      if (this.options.fill) {
        this.canvas.ctx.fillStyle = this.options.color.toString();
      }
      this.canvas.ctx.textAlign = this.options.align;
      this.canvas.ctx.textBaseline = this.options.baseline;
      font = [];
      if (this.options.italic) {
        font.push('italic');
      }
      if (this.options.bold) {
        font.push('bold');
      }
      font.push("" + this.options.size + "px");
      font.push(this.options.font);
      this.canvas.ctx.font = font.join(' ');
      if (this.options.fill) {
        this.canvas.ctx.fillText(this.options.label, 0, 0);
      }
      if (this.options.stroke) {
        this.canvas.ctx.lineWidth = this.options.stroke;
        this.canvas.ctx.strokeStyle = this.options.strokeColor.toString();
        return this.canvas.ctx.strokeText(this.options.label, 0, 0);
      }
    };

    return Text;

  })(Shape);

  rippl.Rectangle = Rectangle = (function(_super) {

    __extends(Rectangle, _super);

    function Rectangle(options, canvas) {
      this.addDefaults({
        cornerRadius: 0
      });
      Rectangle.__super__.constructor.call(this, options, canvas);
    }

    Rectangle.prototype.drawPath = function() {
      var anchor, ctx, h, r, w, x, y;
      anchor = this.getAnchor();
      ctx = this.canvas.ctx;
      if (this.options.cornerRadius === 0) {
        return ctx.rect(-anchor.x, -anchor.y, this.options.width, this.options.height);
      } else {
        x = -anchor.x;
        y = -anchor.y;
        w = this.options.width;
        h = this.options.height;
        r = this.options.cornerRadius;
        ctx.moveTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        return ctx.closePath();
      }
    };

    return Rectangle;

  })(Shape);

  rippl.Circle = Circle = (function(_super) {

    __extends(Circle, _super);

    function Circle(options, canvas) {
      this.addDefaults({
        radius: 0,
        angle: Math.PI * 2
      });
      Circle.__super__.constructor.call(this, options, canvas);
      this.options.width = this.options.radius * 2;
      this.options.height = this.options.radius * 2;
    }

    Circle.prototype.drawPath = function() {
      var ctx;
      ctx = this.canvas.ctx;
      ctx.arc(0, 0, this.options.radius, 0, this.options.angle, false);
      if (this.options.angle !== Math.PI * 2) {
        ctx.lineTo(0, 0);
      }
      return ctx.closePath();
    };

    return Circle;

  })(Shape);

  rippl.Ellipse = Ellipse = (function(_super) {

    __extends(Ellipse, _super);

    function Ellipse() {
      return Ellipse.__super__.constructor.apply(this, arguments);
    }

    Ellipse.prototype.drawPath = function() {
      var anchor, ctx, h, magic, ox, oy, w, x, xe, xm, y, ye, ym;
      anchor = this.getAnchor();
      ctx = this.canvas.ctx;
      x = -anchor.x;
      y = -anchor.y;
      w = this.options.width;
      h = this.options.height;
      magic = 0.551784;
      ox = (w / 2) * magic;
      oy = (h / 2) * magic;
      xe = x + w;
      ye = y + h;
      xm = x + w / 2;
      ym = y + h / 2;
      ctx.moveTo(x, ym);
      ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
      ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
      ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
      ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
      return ctx.closePath();
    };

    return Ellipse;

  })(Shape);

  rippl.CustomShape = CustomShape = (function(_super) {

    __extends(CustomShape, _super);

    function CustomShape(options, canvas) {
      this.addDefaults({
        anchorX: 0,
        anchorY: 0
      });
      CustomShape.__super__.constructor.call(this, options, canvas);
      this.path = [];
      this.options.anchorInPixels = true;
    }

    CustomShape.prototype.bind = function(canvas) {
      var fragment, _j, _len1, _ref, _results;
      CustomShape.__super__.bind.call(this, canvas);
      _ref = this.path;
      _results = [];
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        fragment = _ref[_j];
        if (fragment !== null) {
          _results.push(fragment[1].bind(canvas));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    CustomShape.prototype._point = function(x, y) {
      var point;
      if (x.__isPoint && y === void 0) {
        point = x;
      } else {
        point = new Point(x, y);
      }
      if (this.canvas !== null) {
        point.bind(this.canvas);
      }
      return point;
    };

    CustomShape.prototype.drawPath = function() {
      var anchor, ctx, fragment, method, point, _j, _len1, _ref, _results;
      anchor = this.getAnchor();
      ctx = this.canvas.ctx;
      ctx.moveTo(-anchor.x, -anchor.y);
      _ref = this.path;
      _results = [];
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        fragment = _ref[_j];
        if (fragment === null) {
          _results.push(ctx.closePath());
        } else {
          method = fragment[0], point = fragment[1];
          _results.push(ctx[method](point.x - anchor.x, point.y - anchor.y));
        }
      }
      return _results;
    };

    CustomShape.prototype.lineTo = function(x, y) {
      var point;
      point = this._point(x, y);
      this.path.push(['lineTo', point]);
      return point;
    };

    CustomShape.prototype.moveTo = function(x, y) {
      var point;
      point = this._point(x, y);
      this.path.push(['moveTo', point]);
      return point;
    };

    CustomShape.prototype.close = function() {
      return this.path.push(null);
    };

    return CustomShape;

  })(Shape);

  rippl.Canvas = Canvas = (function(_super) {

    __extends(Canvas, _super);

    Canvas.prototype.options = {
      id: null,
      width: 0,
      height: 0,
      "static": false
    };

    Canvas.prototype.__isAsset = true;

    Canvas.prototype.__isLoaded = true;

    Canvas.prototype.changed = false;

    Canvas.prototype.unordered = false;

    function Canvas(options) {
      var _this = this;
      this.setOptions(options);
      if (this.options.id !== null) {
        this._canvas = document.getElementById(this.options.id);
        this._width = this.options.width = Number(this._canvas.width);
        this._height = this.options.height = Number(this._canvas.height);
      } else {
        this._canvas = document.createElement('canvas');
        this._canvas.setAttribute('width', this.options.width);
        this._canvas.setAttribute('height', this.options.height);
        this._width = this.options.width;
        this._height = this.options.height;
      }
      this.ctx = this._canvas.getContext('2d');
      this.ctx.save();
      this.elements = [];
      this._hoverElement = null;
      this._canvas.addEventListener('touchstart', (function(e) {
        return _this.delegateInputEvent('touchstart', e, false, true);
      }), true);
      this._canvas.addEventListener('touchend', (function(e) {
        return _this.delegateInputEvent('touchend', e, false, true);
      }), true);
      this._canvas.addEventListener('mousedown', (function(e) {
        return _this.delegateInputEvent('mousedown', e);
      }), true);
      this._canvas.addEventListener('mouseup', (function(e) {
        return _this.delegateInputEvent('mouseup', e);
      }), true);
      this._canvas.addEventListener('click', (function(e) {
        return _this.delegateInputEvent('click', e);
      }), true);
      this._canvas.addEventListener('mousemove', (function(e) {
        return _this.delegateInputEvent('mousemove', e, true);
      }), true);
      this._canvas.onmouseleave = function(e) {
        return _this.handleMouseLeave();
      };
      if (!this.options["static"]) {
        rippl.timer.bind(this);
      }
    }

    Canvas.prototype.delegateInputEvent = function(type, e, hover, touch) {
      var element, elements, index, te, x, y;
      if (touch) {
        te = e.touches[0] || e.changedTouches[0];
        x = te.pageX - this._canvas.offsetTop;
        y = te.pageY - this._canvas.offsetLeft;
      } else {
        x = e.layerX;
        y = e.layerY;
      }
      e.preventDefault();
      elements = this.elements;
      index = elements.length;
      while (index--) {
        element = elements[index];
        if (element.delegateInputEvent(type, x, y)) {
          if (hover) {
            if (element === this._hoverElement) {
              return;
            }
            if (this._hoverElement !== null) {
              this._hoverElement.trigger('mouseleave');
            }
            this._hoverElement = element;
            element.trigger('mouseenter');
          }
          return;
        }
      }
      this.trigger(type);
      if (hover) {
        return this.handleMouseLeave();
      }
    };

    Canvas.prototype.handleMouseLeave = function() {
      if (this._hoverElement !== null) {
        this._hoverElement.trigger('mouseleave');
        return this._hoverElement = null;
      }
    };

    Canvas.prototype.getDocumentElement = function() {
      return this._canvas;
    };

    Canvas.prototype.fill = function(color) {
      this.ctx.fillStyle = color.toString();
      return this.ctx.fill();
    };

    Canvas.prototype.stroke = function(width, color) {
      this.ctx.lineWidth = width;
      this.ctx.strokeStyle = color.toString();
      return this.ctx.stroke();
    };

    Canvas.prototype.setShadow = function(x, y, blur, color) {
            if (x != null) {
        x;

      } else {
        x = 0;
      };
            if (y != null) {
        y;

      } else {
        y = 0;
      };
            if (blur != null) {
        blur;

      } else {
        blur = 0;
      };
            if (color != null) {
        color;

      } else {
        color = '#000000';
      };
      this.ctx.shadowOffsetX = x;
      this.ctx.shadowOffsetY = y;
      this.ctx.shadowBlur = blur;
      return this.ctx.shadowColor = color.toString();
    };

    Canvas.prototype.add = function() {
      var element, elements, _j, _len1, _results,
        _this = this;
      elements = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _results = [];
      for (_j = 0, _len1 = elements.length; _j < _len1; _j++) {
        element = elements[_j];
        if (!element.__isElement) {
          throw "Tried to add a non-Element to Canvas";
        }
        element.bind(this);
        this.elements.push(element);
        this.touch();
        this.unordered = true;
        element.on('change', function() {
          return _this.touch();
        });
        element.on('change:z', function() {
          return _this.unordered = true;
        });
        _results.push(element);
      }
      return _results;
    };

    Canvas.prototype.remove = function(elementToDelete) {
      var element, filtered, _j, _len1, _ref;
      filtered = [];
      _ref = this.elements;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        element = _ref[_j];
        if (element !== elementToDelete) {
          filtered.push(element);
        } else {
          element.off();
          delete element.canvas;
        }
      }
      this.elements = filtered;
      return this.touch();
    };

    Canvas.prototype.wipe = function() {
      var element, _j, _len1, _ref;
      _ref = this.elements;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        element = _ref[_j];
        delete element.canvas;
      }
      this.elements = [];
      return this.touch();
    };

    Canvas.prototype.reorder = function() {
      this.elements.sort(function(a, b) {
        return a.get('z') - b.get('z');
      });
      return this.unordered = false;
    };

    Canvas.prototype.touch = function() {
      return this.changed = true;
    };

    Canvas.prototype.clear = function() {
      return this.ctx.clearRect(0, 0, this.options.width, this.options.height);
    };

    Canvas.prototype.render = function(frameTime) {
      var element, _j, _k, _len1, _len2, _ref, _ref1;
      _ref = this.elements;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        element = _ref[_j];
        element.progress(frameTime);
      }
      if (!this.changed) {
        return;
      }
      if (this.unordered) {
        this.reorder();
      }
      this.clear();
      _ref1 = this.elements;
      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
        element = _ref1[_k];
        if (!element.isHidden()) {
          this.ctx.save();
          element.prepare();
          element.render();
          this.ctx.restore();
        }
      }
      return this.changed = false;
    };

    Canvas.prototype.drawAsset = function(asset, x, y, width, height, cropX, cropY) {
      var element;
      if (!asset || !asset.__isAsset) {
        return;
      }
      element = asset.getDocumentElement();
      if (!element) {
        return;
      }
            if (cropX != null) {
        cropX;

      } else {
        cropX = 0;
      };
            if (cropY != null) {
        cropY;

      } else {
        cropY = 0;
      };
      return this.ctx.drawImage(element, cropX, cropY, width, height, x, y, width, height);
    };

    Canvas.prototype.filter = function() {
      var args, filter, fn;
      filter = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      fn = rippl.filters[filter];
      if (typeof fn !== 'function') {
        return;
      }
      return fn.apply(this, args);
    };

    Canvas.prototype.rgbaFilter = function(filter) {
      var i, imageData, l, pixels, _ref;
      imageData = this.ctx.getImageData(0, 0, this.options.width, this.options.height);
      pixels = imageData.data;
      i = 0;
      l = pixels.length;
      while (i < l) {
        _ref = filter(pixels[i], pixels[i + 1], pixels[i + 2], pixels[i + 3]), pixels[i] = _ref[0], pixels[i + 1] = _ref[1], pixels[i + 2] = _ref[2], pixels[i + 3] = _ref[3];
        i += 4;
      }
      return this.ctx.putImageData(imageData, 0, 0);
    };

    return Canvas;

  })(ObjectAbstract);

  if (typeof define === 'function') {
    define('rippl', window.rippl);
  }

}).call(this);
